import logging
import os
import argparse
import sys
import shutil
import json

from atils import config
from atils import yaml_utils
from atils import grafana_utils

from kubernetes import config as kubernetes_config
from kubernetes import client, utils

kubernetes_config.load_kube_config()  # type: ignore

# TODO make it so that logging is set up using config stored in config.py
logging.basicConfig(level=logging.DEBUG)  # type: ignore


def main(args: str):
  parser: argparse.ArgumentParser = argparse.ArgumentParser()
  subparsers = parser.add_subparsers(
    help="Select a subcommand", dest="subparser_name"
  )

  # Options for RKE cluster setup
  rke_parser = subparsers.add_parser(
    "rke-setup", help="Commands to manage the rke installation"
  )
  rke_parser.add_argument(
    "-f",
    "--force",
    help="force the recreation of a cluster, in cases where it's already running",
  )
  rke_parser.add_argument(
    "-rk",
    "--replace-kubeconfig",
    help="Copies a kubeconfig generated by rke to the system-wide kubeconfig",
    action="store_true",
    default=False,
  )
  rke_parser.add_argument(
    "cluster_name",
    help="the name of the cluster to set up. This should match an rke file",
  )

  argocd_parser = subparsers.add_parser(
    "argocd", help="Commands to manage argocd and install applications"
  )
  argocd_parser.add_argument(
    "command",
    choices=["install"],
    help="ArgoCD command to use",
  )
  argocd_parser.add_argument("application_name", nargs="?")

  if len(args) == 0:
    parser.print_help(sys.stderr)
    sys.exit(1)

  args = parser.parse_args(args)

  if args.subparser_name == "rke-setup":
    if vars(args).get("replace_kubeconfig"):
      merge_and_replace_kubeconfig(args.cluster_name)
    else:
      setup_rke_cluster(
        args.cluster_name,
      )
  elif args.subparser_name == "argocd":
    args_dict = vars(args)
    if args_dict["command"] == "install":
      setup_argocd()
    #elif args_dict["command"] == "application-install":
      #install_argocd_application(args_dict["application_name"])


def install_argocd_application(application_name: str):
  with open(f"{config.SCRIPT_INSTALL_DIRECTORY}/atils/command-configurations/argocd-applications.json") as f:
    data = json.load(f)

  if not application_name:
    for item in data:
      name = item['name']
      description = item['description']
      url = item['url']
      print(f'{name} - {description} - {url}')
  else:
    for item in data:
      if item['name'] == application_name:
        k8s_client = client.ApiClient()
        v1 = client.CoreV1Api()

        try:
          namespace = item["namespace"]
          v1.read_namespace(name=namespace)
          print(f"The {namespace} namespace exists, skipping namespace creation.")
        except client.exceptions.ApiException as e:
          if e.status == 404:
              logging.info(f"The {application_name} namespace does not exist. Creating namespace")
              utils.create_from_yaml(
                k8s_client,
                f"{config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/namespaces/{application_name}.yaml",
              )
          else:
            logging.error("Unexpected error:", e)
            exit(1)

          if "pre-install-yaml" in item:
            pre = item["pre-install-yaml"]
            os.system(
              f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/post-install/{pre}"
            )

        for application in item["application-yaml"]:
          os.system(
            f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/applications/{application}",
          )

        if "gateway" in item:
          for gateway in item["gateway"]:
            os.system(f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/istio/gateways/{gateway}")

        if "prometheus" in item:
          for gateway in item["prometheus"]:
            os.system(f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/prometheus/{gateway}")

        if "grafana" in item:
          grafana_utils.install_dashboards(item["grafana"])

        if "post-install-yaml" in item:
          post = item["post-install-yaml"]
          os.system(
            f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/post-install/{post}"
          )

        ''''''


def setup_argocd():
  k8s_client = client.ApiClient()

  if(not check_namespace_exists("argocd")):
    utils.create_from_yaml(
      k8s_client,
      f"{config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/namespaces/argocd.yaml",
    )

  os.system(
    f"helm repo add argo https://argoproj.github.io/argo-helm && helm upgrade --install argocd -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/values.yaml argo/argo-cd -n argocd"
  )

  os.system(
    f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/master-app.yaml"
  )

  os.system(
    f"kubectl apply -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/setup/cluster-role-binding.yaml -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/setup/cmp-plugin.yaml -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/setup/vault-authorization-secret.yaml"
  )

def merge_and_replace_kubeconfig(cluster_name):
  shutil.copy(
    f"{config.KUBECONFIG_LOCATION}/config",
    f"{config.KUBECONFIG_LOCATION}/config.bak",
  )
  merged_kubeconfig = yaml_utils.merge_kubeconfigs(
    f"{config.KUBECONFIG_LOCATION}/config",
    os.path.join(
      config.SCRIPT_INSTALL_DIRECTORY,
      f"../kubernetes/rke/kube_config_{cluster_name}.yaml",
    ),
  )

  with open(f"{config.KUBECONFIG_LOCATION}/config", "w") as kfile:
    kfile.truncate(0)
    kfile.write(merged_kubeconfig)


def check_cluster_availability() -> bool:
  try:
    contexts, active_context = kubernetes_config.list_kube_config_contexts()
    cluster_name: str = active_context["context"]["cluster"]
    logging.debug(f"Checking cluster availability for cluster: {cluster_name}")
    # Create a CoreV1Api instance
    api_instance = client.CoreV1Api()

    # Get the list of nodes in the cluster
    api_response = api_instance.list_node(timeout_seconds=5)

    # Check if the cluster is reachable
    if api_response:
      logging.info(f"Cluster '{cluster_name}' is reachable.")
      return True
    else:
      logging.info(f"Cluster '{cluster_name}' is not reachable.")
      return False
  except Exception as e:
    if "[Errno 64]" in e.args[0]:
      logging.error(
        'Cluster host is down. If you are trying to setup a new cluster, use the "rke-setup [cluster_name]" subcommand'
      )
      return False
    elif "Max retries execeeded with url:" in e.args[0]:
      logging.error(
        'Cluster host is unreachable. If you are trying to setup a new cluster, use the "rke-setup [cluster_name]" subcommand'
      )
      return False

    else:
      logging.error("We found a new kind of issue! This is a bug.")
      logging.error(e)
      return False


def setup_rke_cluster(cluster_name: str, force: bool = False):
  cluster_availability = check_cluster_availability()

  if cluster_availability and not (force):
    logging.error(
      "Cluster was reachable and --force was not used. If you wish to overwrite your cluster, use --force."
    )
    exit(0)
  elif not (cluster_availability) or force:
    # TODO Make this take config, and try to move these configuration files
    cluster_config_location: str = os.path.join(
      config.SCRIPT_INSTALL_DIRECTORY, f"../kubernetes/rke/{cluster_name}.yaml"
    )
    print(cluster_config_location)
    if os.path.isfile(cluster_config_location):
      # TODO we should add our own error checking here, rather than relying on RKE's.
      os.system(f"rke up --config {cluster_config_location}")
      merge_and_replace_kubeconfig(cluster_name)
    else:
      logging.error(
        f"Could not find an rke file named {cluster_name}.yaml. Aborting"
      )
      exit(1)


def check_namespace_exists(namespace_name: str) -> bool:
  # Create Kubernetes API client
  v1 = client.CoreV1Api()

  # Use the API client to list all namespaces
  namespace_list = v1.list_namespace().items

  # Check if the namespace exists
  if any(namespace.metadata.name == namespace_name for namespace in namespace_list):
      return True
  else:
      return False