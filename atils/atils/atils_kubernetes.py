import logging
import os
import argparse
import sys
import shutil
import yaml
import subprocess
import webbrowser
import base64

from atils import config
from atils import yaml_utils
from atils import template_utils

from kubernetes import config as k8s_config
from kubernetes import client

k8s_config.load_kube_config()  # type: ignore
client.rest.logger.setLevel(logging.WARNING)

# TODO make it so that logging is set up using config stored in config.py
logging.basicConfig(level=logging.DEBUG)  # type: ignore


def main(args: str):
    parser: argparse.ArgumentParser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        help="Select a subcommand", dest="subparser_name"
    )

    # Options for managing kubernetes secrets. This is different from Vault secrets management
    secrets_parser = subparsers.add_parser(
        "secrets", help="Commands to manage kubernetes secrets"
    )

    secrets_parser.add_argument(
        "command", choices=["decode"], help="Which command to use to operate on secrets"
    )

    secrets_parser.add_argument(
        "secret_name", help="The name of the secret to operate on"
    )

    secrets_parser.add_argument(
        "-n", "--namespace", help="The namespace of the secret to operate on"
    )

    # Options for RKE cluster setup
    rke_parser = subparsers.add_parser(
        "rke-setup", help="Commands to manage the rke installation"
    )
    rke_parser.add_argument(
        "-f",
        "--force",
        help="force the recreation of a cluster, in cases where it's already running",
    )
    rke_parser.add_argument(
        "-rk",
        "--replace-kubeconfig",
        help="Copies a kubeconfig generated by rke to the system-wide kubeconfig",
        action="store_true",
        default=False,
    )
    rke_parser.add_argument(
        "cluster_name",
        help="the name of the cluster to set up. This should match an rke file",
    )

    argocd_parser = subparsers.add_parser(
        "argocd", help="Commands to manage argocd and install applications"
    )
    argocd_parser.add_argument(
        "command",
        choices=["install", "port-forward"],
        help="ArgoCD command to use",
    )
    # using argparse, add an optional argument named "enviornment" that can either be 'dev-laptop', 'dev-vms', or 'prod'
    argocd_parser.add_argument(
        "--environment",
        "-e",
        choices=["dev-laptop", "dev-vms", "prod"],
        help="Environment to install applications in",
    )

    if len(args) == 0:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args(args)

    if args.subparser_name == "rke-setup":
        if vars(args).get("replace_kubeconfig"):
            merge_and_replace_kubeconfig(args.cluster_name)
        else:
            setup_rke_cluster(
                args.cluster_name,
            )

    elif args.subparser_name == "argocd":
        args_dict = vars(args)
        if args_dict["command"] == "install":
            # call setup_argocd with the environment as an argument, using the --environment argument. If --environment was not provided, fail
            if args_dict["environment"] is None:
                logging.error("Please provide an environment")
                sys.exit(1)
            else:
                setup_argocd(args_dict["environment"])
        elif args_dict["command"] == "port-forward":
            open_argocd_port_forward()

    elif args.subparser_name == "secrets":
        args_dict = vars(args)
        if args_dict["command"] == "decode":
            if args_dict["secret_name"] is None:
                logging.error("Error: A secret name must be provided ")
                sys.exit(1)
            else:
                get_and_decode_secret(args_dict["secret_name"], args_dict["namespace"])


def setup_argocd(environment: str):
    custom_objects_api = client.CustomObjectsApi()
    if not check_namespace_exists("argocd"):
        api = client.CoreV1Api()

        # Create the namespace
        namespace_body = client.V1Namespace(metadata=client.V1ObjectMeta(name="argocd"))
        api.create_namespace(namespace_body)

    result = subprocess.run(
        f"""helm repo add argo https://argoproj.github.io/argo-helm && helm -n argocd upgrade --install argocd -f {config.SCRIPT_INSTALL_DIRECTORY}/../kubernetes/argocd/values.yaml argo/argo-cd""",
        shell=True,
        capture_output=True,
    )

    if result.returncode == 0:
        logging.info("ArgoCD Helm chart successfully installed")
    else:
        logging.warning(result.stdout)
        logging.warning(
            "ArgoCD Helm chart failed to install. This may simply be because it is already installed, which we don't check"
        )

    master_app_string = template_utils.template_file(
        "master-app.yaml", {"environment": environment}
    )
    master_app_dict = yaml.safe_load(master_app_string)

    # Check whether an argocd application named 'master-stack' exists
    try:
        custom_objects_api.get_namespaced_custom_object(
            group="argoproj.io",
            version="v1alpha1",
            namespace="argocd",
            plural="applications",
            name="master-stack",
        )
    except client.exceptions.ApiException as e:
        if e.status == 404:
            logging.info("No application named 'master-stack' exists, creating it")
            custom_objects_api.create_namespaced_custom_object(
                group="argoproj.io",
                version="v1alpha1",
                namespace="argocd",
                plural="applications",
                body=master_app_dict,
                pretty=True,
            )
        else:
            logging.info(
                "Master-stack already exists. If you want to force a recreation, use --force-master-reconfiguration[Not yet working]"
            )


def merge_and_replace_kubeconfig(cluster_name):
    shutil.copy(
        f"{config.KUBECONFIG_LOCATION}/config",
        f"{config.KUBECONFIG_LOCATION}/config.bak",
    )
    merged_kubeconfig = yaml_utils.merge_kubeconfigs(
        f"{config.KUBECONFIG_LOCATION}/config",
        os.path.join(
            config.SCRIPT_INSTALL_DIRECTORY,
            f"../kubernetes/rke/kube_config_{cluster_name}.yaml",
        ),
    )

    with open(f"{config.KUBECONFIG_LOCATION}/config", "w") as kfile:
        kfile.truncate(0)
        kfile.write(merged_kubeconfig)


def check_cluster_availability() -> bool:
    try:
        contexts, active_context = k8s_config.list_kube_config_contexts()
        cluster_name: str = active_context["context"]["cluster"]
        logging.debug(f"Checking cluster availability for cluster: {cluster_name}")
        # Create a CoreV1Api instance
        api_instance = client.CoreV1Api()

        # Get the list of nodes in the cluster
        api_response = api_instance.list_node(timeout_seconds=5)

        # Check if the cluster is reachable
        if api_response:
            logging.info(f"Cluster '{cluster_name}' is reachable.")
            return True
        else:
            logging.info(f"Cluster '{cluster_name}' is not reachable.")
            return False
    except Exception as e:
        if "[Errno 64]" in e.args[0]:
            logging.error(
                'Cluster host is down. If you are trying to setup a new cluster, use the "rke-setup [cluster_name]" subcommand'
            )
            return False
        elif "Max retries execeeded with url:" in e.args[0]:
            logging.error(
                'Cluster host is unreachable. If you are trying to setup a new cluster, use the "rke-setup [cluster_name]" subcommand'
            )
            return False

        else:
            logging.error("We found a new kind of issue! This is a bug.")
            logging.error(e)
            return False


def setup_rke_cluster(cluster_name: str, force: bool = False):
    cluster_availability = check_cluster_availability()

    if cluster_availability and not (force):
        logging.error(
            "Cluster was reachable and --force was not used. If you wish to overwrite your cluster, use --force."
        )
        exit(0)
    elif not (cluster_availability) or force:
        # TODO Make this take config, and try to move these configuration files
        cluster_config_location: str = os.path.join(
            config.SCRIPT_INSTALL_DIRECTORY, f"../kubernetes/rke/{cluster_name}.yaml"
        )
        if os.path.isfile(cluster_config_location):
            # TODO we should add our own error checking here, rather than relying on RKE's.
            os.system(f"rke up --config {cluster_config_location}")
            merge_and_replace_kubeconfig(cluster_name)
        else:
            logging.error(
                f"Could not find an rke file named {cluster_name}.yaml. Aborting"
            )
            exit(1)


def check_namespace_exists(namespace_name: str) -> bool:
    # Create Kubernetes API client
    v1 = client.CoreV1Api()

    # Use the API client to list all namespaces
    namespace_list = v1.list_namespace().items

    # Check if the namespace exists
    if any(namespace.metadata.name == namespace_name for namespace in namespace_list):
        return True
    else:
        return False


def open_argocd_port_forward():
    result = subprocess.run(
        "kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath={{.data.password}} | base64 -d".format(),
        shell=True,
        capture_output=True,
    )
    subprocess.run(
        f"echo {result.stdout.decode('utf-8')} | pbcopy",
        shell=True,
        capture_output=True,
    )
    # Open a new tab in the default browser to localhost:8080 with webbrowser
    webbrowser.open_new_tab("http://localhost:8080/argocd")

    # Port forward to the ArgoCD UI
    subprocess.run(
        "kubectl -n argocd port-forward svc/argocd-server -n argocd 8080:443",
        shell=True,
    )


def get_and_decode_secret(secret_name, secret_namespace):
    try:
        # Create a Kubernetes API client
        api = client.CoreV1Api()

        if secret_namespace is None:
            current_context = k8s_config.list_kube_config_contexts()[1]
            # Check if current_context["context"]["namespace"] is None
            secret_namespace = current_context.get("context").get(
                "namespace", "default"
            )

        # Get the Secret from the specified namespace
        secret = api.read_namespaced_secret(
            name=secret_name, namespace=secret_namespace
        )

        terminal_width = shutil.get_terminal_size().columns

        print("=" * int(terminal_width / 2))
        print(secret.metadata.name.center(int(terminal_width / 2)))
        print("=" * int(terminal_width / 2))

        # Decode and pretty print the data items
        for key, value in secret.data.items():
            decoded_value = base64.b64decode(value).decode("utf-8")
            # If decoded_value is more than one line, print on a new line
            if "\n" in decoded_value:
                print(f"{key}:")
                print(decoded_value)
            else:
                print(f"{key}: {decoded_value}")

            print("=" * int(terminal_width / 2))

    except Exception as e:
        logging.error(f"An error occurred: {e}")
